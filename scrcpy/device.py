# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'd:\git\python\pywinauto-mutictrl\win.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMenu, QAction
import sys
from PyQt5.QtGui import *
from PyQt5.QtCore import *
import threading
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from scrcpy.core import Client
import scrcpy.const as const
import time
import numpy as np
import cv2

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        # åˆå§‹çª—å£å¤§å°ï¼Œåç»­ä¼šæ ¹æ®å›¾åƒå¤§å°åŠ¨æ€è°ƒæ•´
        Form.setFixedSize(400, 800)
        self.img_label = QtWidgets.QLabel(Form)
        self.img_label.setGeometry(QtCore.QRect(0, 1, 400, 800))
        self.img_label.setText("")
        self.img_label.setObjectName("img_label")
        
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Form", "Form"))

class MyWin(QtWidgets.QWidget,Ui_Form):

    def __init__(self, ch_name) -> None:
        
        super(MyWin,self).__init__()
        self.setupUi(self)
        self.setMouseTracking(True)  # å¯ç”¨é¼ æ ‡è·Ÿè¸ª
        self.setWindowTitle(ch_name)

        self.setFixedSize(self.width(), self.height())
        self.img_label.setMouseTracking(True)  # å¯ç”¨å›¾ç‰‡æ ‡ç­¾çš„é¼ æ ‡è·Ÿè¸ª
        
        # è®¾ç½®çª—å£å±æ€§ä»¥æ¥æ”¶äº‹ä»¶
        self.setFocusPolicy(Qt.StrongFocus)  # è®¾ç½®ç„¦ç‚¹ç­–ç•¥
        self.setAttribute(Qt.WA_AcceptTouchEvents, True)  # æ¥å—è§¦æ‘¸äº‹ä»¶
        
        self.rlock = threading.RLock()

        self.mouse_left_down = False
        self.mouse_right_down = False
        self.mouse_x1_down = False
        self.key_alt_down = False
        self.key_ctrl_down = False
        self.win_moving = False
        self.ori_x = 0
        self.ori_y = 0
        
        # é¼ æ ‡äº¤äº’ç›¸å…³
        self.mouse_x = 0
        self.current_frame = None  # å­˜å‚¨å½“å‰å¸§ä»¥ä¾¿åæ ‡è½¬æ¢
        self.mouse_y = 0
        
        # æ»šè½®é…ç½®
        self.scroll_sensitivity = 0.3  # æ»šè½®æ•æ„Ÿåº¦
        self.scroll_min_threshold = 10  # æœ€å°æ»šåŠ¨é˜ˆå€¼
        self.scroll_max_distance = 100  # æœ€å¤§æ»šåŠ¨è·ç¦»
        
        # å…¬å…±ç”»å¸ƒæ”¯æŒ - ä¾›å…¶ä»–æ¨¡å—ç»˜åˆ¶UIå…ƒç´ è¾¹æ¡†
        self.public_canvas = None  # å…¬å…±ç”»å¸ƒï¼Œå…¶ä»–æ¨¡å—å¯ä»¥åœ¨æ­¤ç»˜åˆ¶
        self.canvas_lock = threading.RLock()  # ç”»å¸ƒçº¿ç¨‹é”
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿè®¾å¤‡æ¨¡å¼
        if ch_name == "simulator":
            print("å¯åŠ¨æ¨¡æ‹Ÿè®¾å¤‡æ¨¡å¼...")
            self.client = None
            self.simulator_mode = True
            self.start_simulator()
        else:
            try:
                print(f"æ­£åœ¨åˆå§‹åŒ–å®¢æˆ·ç«¯ï¼Œè®¾å¤‡: {ch_name}")
                self.client = Client(device=ch_name, max_width=800, bitrate=4000000, max_fps=20, connection_timeout=10000)
                print("æ­£åœ¨æ·»åŠ å¸§ç›‘å¬å™¨...")
                self.client.add_listener("frame", self.on_frame)
                print("æ­£åœ¨å¯åŠ¨å®¢æˆ·ç«¯...")
                self.client.start(threaded=True)
                print(f"æˆåŠŸè¿æ¥åˆ°è®¾å¤‡ {ch_name}")
                self.simulator_mode = False
            except Exception as e:
                print(f"è¿æ¥è®¾å¤‡å¤±è´¥: {e}")
                print("è¯·ç¡®ä¿:")
                print("1. Android è®¾å¤‡å·²è¿æ¥å¹¶å¯ç”¨ USB è°ƒè¯•")
                print("2. è¿è¡Œ 'adb devices' ç¡®è®¤è®¾å¤‡å¯è§")
                print("3. è¿è¡Œ 'adb push scrcpy-server.jar /data/local/tmp/' æ¨é€æœåŠ¡å™¨æ–‡ä»¶")
                print("4. åœ¨è®¾å¤‡ä¸Šå…è®¸å±å¹•å½•åˆ¶æƒé™")
                print("å¯åŠ¨æ¨¡æ‹Ÿè®¾å¤‡æ¨¡å¼...")
                self.client = None
                self.simulator_mode = True
                self.start_simulator()
    

    # def dragMoveEvent(self, a0: QtGui.QDragMoveEvent) -> None:
    #     print("drag_move")
    #
    # def dragEnterEvent(self, a0: QtGui.QDragEnterEvent) -> None:
    #     print("drag_enter")
    #
    # def dragLeaveEvent(self, a0: QtGui.QDragLeaveEvent) -> None:
    #     print("drag_leave")    #
    # def dropEvent(self, a0: QtGui.QDropEvent) -> None:
    #     print("drop")

    # def moveEvent(self, a0: QtGui.QMoveEvent) -> None:
        # print("move_event")
        # self.win_moving = True
        # print(self.geometry())

    # def focusOutEvent(self, a0: QtGui.QFocusEvent) -> None:
    #     print("focus_out")
    #     self.win_moving = False
    #
    # def focusInEvent(self, QFocusEvent):
    #     print("focus_in")

    # def resizeEvent(self, a0: QtGui.QResizeEvent) -> None:
    #     print("resize_event")
    #
    # def enterEvent(self, a0: QtCore.QEvent) -> None:
    #     print("mouse_enter")
    #
    # def leaveEvent(self, a0: QtCore.QEvent) -> None:
    #     print("mouse_leave")

    def on_frame(self, frame):
        if frame is not None and frame.size > 0:
            try:
                self.rlock.acquire()
                # å­˜å‚¨å½“å‰å¸§ä»¥ä¾¿åæ ‡è½¬æ¢å’ŒUIåˆ†æ
                self.current_frame = frame
                                
                if not hasattr(self, 'frame_count'):
                    self.frame_count = 0
                    self.last_frame_info_time = 0
                
                self.frame_count += 1
                image_height, image_width, image_depth = frame.shape
                
                # å‡å°‘æ—¥å¿—è¾“å‡ºé¢‘ç‡ï¼Œæ¯30å¸§ï¼ˆçº¦1ç§’ï¼‰æ‰“å°ä¸€æ¬¡
                current_time = time.time()
                if current_time - self.last_frame_info_time > 1.0:
                    print(f"æ”¶åˆ°å¸§: {image_width}x{image_height}, FPS: {self.frame_count}/{current_time - self.last_frame_info_time:.1f}")
                    self.frame_count = 0
                    self.last_frame_info_time = current_time
                                
                # åŠ¨æ€è°ƒæ•´çª—å£å¤§å°ä»¥åŒ¹é…å›¾åƒå¤§å°
                if not hasattr(self, 'window_resized') or not self.window_resized:
                    self.resize(image_width, image_height)
                    self.img_label.setGeometry(QtCore.QRect(0, 1, image_width, image_height))
                    self.window_resized = True
                    print(f"çª—å£å¤§å°å·²è°ƒæ•´ä¸º: {image_width}x{image_height}")
                
                # å¤„ç†å…¬å…±ç”»å¸ƒæ¸²æŸ“ - å°†UIå…ƒç´ è¾¹æ¡†å åŠ åˆ°frameä¸Š
                display_frame = frame.copy()
                with self.canvas_lock:
                    if self.public_canvas is not None:
                        try:
                            # ç¡®ä¿ç”»å¸ƒå°ºå¯¸ä¸frameåŒ¹é…
                            if self.public_canvas.shape[:2] == (image_height, image_width):
                                # å°†ç”»å¸ƒå†…å®¹å åŠ åˆ°frameä¸Š
                                # ä½¿ç”¨åŠ æƒæ··åˆï¼Œè®©åŸå›¾å¯è§ï¼Œç”»å¸ƒå†…å®¹ä½œä¸ºè¦†ç›–å±‚
                                alpha = 0.6  # åŸå›¾é€æ˜åº¦
                                beta = 0.4   # ç”»å¸ƒé€æ˜åº¦ - æé«˜è¾¹æ¡†å¯è§æ€§
                                display_frame = cv2.addWeighted(display_frame, alpha, self.public_canvas, beta, 0)
                            else:
                                # å¦‚æœå°ºå¯¸ä¸åŒ¹é…ï¼Œé‡ç½®ç”»å¸ƒ
                                print(f"ç”»å¸ƒå°ºå¯¸ä¸åŒ¹é…ï¼Œé‡ç½®: æœŸæœ›{(image_height, image_width)}, å®é™…{self.public_canvas.shape[:2]}")
                                self.public_canvas = None
                        except Exception as e:
                            print(f"ç”»å¸ƒæ¸²æŸ“é”™è¯¯: {e}")
                            self.public_canvas = None
                                
                q_im = cv2.cvtColor(display_frame, cv2.COLOR_BGR2RGB)
                q_im = QImage(q_im.data, image_width, image_height,  # åˆ›å»ºQImageæ ¼å¼çš„å›¾åƒï¼Œå¹¶è¯»å…¥å›¾åƒä¿¡æ¯
                             image_width * image_depth,
                             QImage.Format_RGB888)
                self.img_label.setPixmap(QPixmap.fromImage(q_im))
                # print("å¸§å·²æ˜¾ç¤º")
            except Exception as e:
                print("çº¿ç¨‹å‡ºé”™%s"%(e))
            finally:
                self.rlock.release()
        else:
            pass
            # print("æ”¶åˆ°ç©ºå¸§æˆ–æ— æ•ˆå¸§")

    def set_public_canvas(self, canvas):
        """è®¾ç½®å…¬å…±ç”»å¸ƒï¼Œä¾›å…¶ä»–æ¨¡å—ç»˜åˆ¶UIå…ƒç´ è¾¹æ¡†
        
        Args:
            canvas: OpenCVæ ¼å¼çš„ç”»å¸ƒ(numpy array)ï¼Œæˆ–Noneæ¸…ç©ºç”»å¸ƒ
        """
        with self.canvas_lock:
            self.public_canvas = canvas
    
    def get_frame_size(self):
        """è·å–å½“å‰å¸§çš„å°ºå¯¸ï¼Œä¾›å…¶ä»–æ¨¡å—åˆ›å»ºåŒ¹é…çš„ç”»å¸ƒ
        
        Returns:
            tuple: (height, width) æˆ– Noneå¦‚æœæœªæ¥æ”¶åˆ°å¸§
        """
        if hasattr(self, 'current_frame') and self.current_frame is not None:
            return self.current_frame.shape[:2]
        return None
    
    def create_empty_canvas(self):
        """åˆ›å»ºä¸å½“å‰å¸§å°ºå¯¸åŒ¹é…çš„ç©ºç”»å¸ƒ
        
        Returns:
            numpy.ndarray: ç©ºçš„BGRç”»å¸ƒï¼Œæˆ–Noneå¦‚æœæ— æ³•åˆ›å»º
        """
        frame_size = self.get_frame_size()
        if frame_size is not None:
            height, width = frame_size
            return np.zeros((height, width, 3), dtype=np.uint8)
        return None




    def show_help(self):
        """æ˜¾ç¤ºå¿«æ·é”®å¸®åŠ©ä¿¡æ¯"""
        print("\n" + "="*50)
        print("ğŸ® Androidåˆ†æå™¨ - å¿«æ·é”®å¸®åŠ©")
        print("="*50)
        print("ğŸ’¡ åŸºç¡€åŠŸèƒ½:")
        print("  â€¢ åŸºç¡€scrcpyå±å¹•é•œåƒåŠŸèƒ½")
        print("  â€¢ æ”¯æŒå…¬å…±ç”»å¸ƒç”¨äºå¤–éƒ¨UIç»˜åˆ¶")
        print("  â€¢ æ”¹è¿›çš„æ»šè½®æ»šåŠ¨æ§åˆ¶")
        print("")
        print("ğŸ–±ï¸ æ»šè½®æ§åˆ¶:")
        print("  â€¢ é¼ æ ‡æ»šè½®: åœ¨è§†é¢‘åŒºåŸŸå†…æ»šåŠ¨")
        print("  â€¢ + é”®: å¢åŠ æ»šè½®æ•æ„Ÿåº¦")
        print("  â€¢ - é”®: å‡å°‘æ»šè½®æ•æ„Ÿåº¦")
        print("  â€¢ 0 é”®: é‡ç½®æ»šè½®è®¾ç½®ä¸ºé»˜è®¤å€¼")
        print("")
        print("ğŸ“Š å½“å‰æ»šè½®è®¾ç½®:")
        print(f"  â€¢ æ•æ„Ÿåº¦: {self.scroll_sensitivity}")
        print(f"  â€¢ æœ€å°é˜ˆå€¼: {self.scroll_min_threshold}")
        print(f"  â€¢ æœ€å¤§è·ç¦»: {self.scroll_max_distance}")
        print("="*50)


    def wheelEvent(self, a0: QtGui.QWheelEvent) -> None:
        if self.client is None:
            return
            
        # è·å–é¼ æ ‡åœ¨çª—å£ä¸­çš„ä½ç½®
        mouse_x = a0.x()
        mouse_y = a0.y()
        
        # æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨è§†é¢‘åŒºåŸŸå†…
        if not self.img_label.geometry().contains(mouse_x, mouse_y):
            return
            
        # è·å–æ»šè½®è§’åº¦å¢é‡
        angle_delta = a0.angleDelta().y()
        
        # è®¡ç®—æ»šåŠ¨è·ç¦»ï¼ˆæ ¹æ®è§’åº¦å¢é‡è°ƒæ•´æ•æ„Ÿåº¦ï¼‰
        scroll_distance = int(angle_delta * self.scroll_sensitivity)
        
        # ç¡®ä¿æ»šåŠ¨è·ç¦»åœ¨åˆç†èŒƒå›´å†…
        scroll_distance = max(-self.scroll_max_distance, min(self.scroll_max_distance, scroll_distance))
        
        # å¦‚æœæ»šåŠ¨è·ç¦»ä¸º0ï¼Œä¸æ‰§è¡Œæ»šåŠ¨
        if scroll_distance == 0:
            return
            
        # ä½¿ç”¨scrollæ–¹æ³•è¿›è¡Œæ»šåŠ¨ï¼Œè€Œä¸æ˜¯ç¡¬ç¼–ç çš„è§¦æ‘¸äº‹ä»¶
        # scrollæ–¹æ³•éœ€è¦æ°´å¹³ä½ç½®ã€å‚ç›´ä½ç½®ã€æ°´å¹³ç§»åŠ¨è·ç¦»ã€å‚ç›´ç§»åŠ¨è·ç¦»
        try:
            self.client.control.scroll(mouse_x, mouse_y, 0, scroll_distance)
            print(f"ğŸ–±ï¸ æ»šè½®äº‹ä»¶: ä½ç½®({mouse_x}, {mouse_y}), è§’åº¦å¢é‡: {angle_delta}, æ»šåŠ¨è·ç¦»: {scroll_distance}")
        except Exception as e:
            print(f"âŒ æ»šè½®äº‹ä»¶å¤„ç†å¤±è´¥: {e}")
    
    def set_scroll_sensitivity(self, sensitivity: float):
        """è®¾ç½®æ»šè½®æ•æ„Ÿåº¦
        
        Args:
            sensitivity: æ•æ„Ÿåº¦ç³»æ•°ï¼Œå»ºè®®èŒƒå›´ 0.1-1.0
        """
        self.scroll_sensitivity = max(0.1, min(1.0, sensitivity))
        print(f"ğŸ›ï¸ æ»šè½®æ•æ„Ÿåº¦å·²è®¾ç½®ä¸º: {self.scroll_sensitivity}")
    
    def set_scroll_threshold(self, threshold: int):
        """è®¾ç½®æ»šè½®æœ€å°é˜ˆå€¼
        
        Args:
            threshold: æœ€å°è§’åº¦å¢é‡é˜ˆå€¼
        """
        self.scroll_min_threshold = max(1, threshold)
        print(f"ğŸ›ï¸ æ»šè½®æœ€å°é˜ˆå€¼å·²è®¾ç½®ä¸º: {self.scroll_min_threshold}")
    
    def set_scroll_max_distance(self, max_distance: int):
        """è®¾ç½®æ»šè½®æœ€å¤§æ»šåŠ¨è·ç¦»
        
        Args:
            max_distance: æœ€å¤§æ»šåŠ¨è·ç¦»
        """
        self.scroll_max_distance = max(10, max_distance)
        print(f"ğŸ›ï¸ æ»šè½®æœ€å¤§è·ç¦»å·²è®¾ç½®ä¸º: {self.scroll_max_distance}")

    def mouseMoveEvent(self, a0: QtGui.QMouseEvent) -> None:
        # æ›´æ–°é¼ æ ‡ä½ç½®
        self.mouse_x = a0.x()
        self.mouse_y = a0.y()
                
        if self.client is None:
            return
        if self.mouse_left_down:
            self.client.control.touch(a0.x(), a0.y(),const.ACTION_MOVE, 2)
        if self.mouse_right_down is True:
            x_deviation = a0.x() - self.ori_x
            y_deviation = a0.y() - self.ori_y
            self.client.control.touch(129+x_deviation, 428+y_deviation,const.ACTION_MOVE, 2)

    def mousePressEvent(self, a0: QtGui.QMouseEvent) -> None:
        if self.client is None:
            return
        if a0.button() == Qt.LeftButton:
            self.mouse_left_down = True
            self.client.control.touch(a0.x(), a0.y(), const.ACTION_DOWN, 2)
        if a0.button() == Qt.RightButton:
            self.mouse_right_down = True
            self.ori_x = a0.x()
            self.ori_y = a0.y()
            x_deviation = 60 if a0.x() - self.ori_x > 0 else -60
            y_deviation = 60 if a0.y() - self.ori_y > 0 else -60
            self.client.control.touch(129+x_deviation, 428+y_deviation, const.ACTION_DOWN, 2)

    def mouseDoubleClickEvent(self, a0: QtGui.QMouseEvent) -> None:
        return super().mouseDoubleClickEvent(a0)

    def mouseReleaseEvent(self, a0: QtGui.QMouseEvent) -> None:
        if self.client is None:
            return
        if a0.button() == Qt.LeftButton:
            self.mouse_left_down = False
            self.client.control.touch(a0.x(), a0.y(), const.ACTION_UP, 2)
        if a0.button() == Qt.RightButton:
            self.mouse_right_down = False
            self.client.control.touch(129, 428, const.ACTION_UP, 2)

    def keyPressEvent(self, a0: QtGui.QKeyEvent) -> None:
        print(f"ğŸ”‘ æŒ‰é”®äº‹ä»¶: {a0.key()}, å­—ç¬¦: {a0.text()}")  # æ·»åŠ è°ƒè¯•ä¿¡æ¯
        if a0.isAutoRepeat() or self.key_ctrl_down or self.key_alt_down:
            return
        if a0.key() == Qt.Key.Key_Alt:
            self.key_alt_down = True
        if a0.key() == Qt.Key.Key_Control:
            self.key_ctrl_down = True
        if a0.key() == Qt.Key_Space:
            if self.win_moving:
                self.win_moving = False
        # elif a0.key() == Qt.Key_A:
        #     self.character.use_skill_manually_down(self.character.skill_riding_slot)
        # elif a0.key() == Qt.Key_Q:
        #     self.character.use_skill_manually_down(self.character.skill_main_weapon_slot1)
        # elif a0.key() == Qt.Key_W:
        #     self.character.use_skill_manually_down(self.character.skill_main_weapon_slot2)
        # elif a0.key() == Qt.Key_E:
        #     self.character.use_skill_manually_down(self.character.skill_main_weapon_slot3)
        # elif a0.key() == Qt.Key_R:
        #     self.character.use_skill_manually_down(self.character.skill_armor_slot)
        # elif a0.key() == Qt.Key_F:
        #     self.character.use_skill_manually_down(self.character.skill_shoes_slot)
        # elif a0.key() == Qt.Key_D:
        #     self.character.use_skill_manually_down(self.character.skill_head_slot)
        elif a0.key() == Qt.Key_C:
            pass
        # Ué”®åŠŸèƒ½å·²ç§»é™¤ - UIAutomator2 ä¸å¯ç”¨
        # elif a0.key() == Qt.Key_D:  # D é”®æ·»åŠ  dumpsys ä¿¡æ¯æ˜¾ç¤º
        #     self.show_dumpsys_info()
        # elif a0.key() == Qt.Key_H:  # H é”®åˆ‡æ¢æ‚¬åœé«˜äº®
        #     self.toggle_hover_highlight()
        # elif a0.key() == Qt.Key_P:  # P é”®åˆ‡æ¢æ€§èƒ½æ¨¡å¼
        #     self.toggle_performance_mode()
        # elif a0.key() == Qt.Key_M:  # M é”®è°ƒæ•´æœ€å¤§å…ƒç´ æ•°é‡
        #     self.adjust_max_elements()
        # elif a0.key() == Qt.Key_I:  # I é”®è°ƒæ•´åˆ†æé—´éš”
        #     self.adjust_analysis_interval()
        # elif a0.key() == Qt.Key_S:  # S é”®æ˜¾ç¤ºæ€§èƒ½ç»Ÿè®¡
        #     self.show_performance_stats()
        # elif a0.key() == Qt.Key_F:  # F é”®åˆ‡æ¢å¿«é€Ÿ/æ ‡å‡†åˆ†æå™¨
        #     self.toggle_analyzer()
        elif a0.key() == Qt.Key_Question or a0.key() == Qt.Key_Slash:  # ? é”®æ˜¾ç¤ºå¸®åŠ©
            self.show_help()
        elif a0.key() == Qt.Key_Plus or a0.key() == Qt.Key_Equal:  # + é”®å¢åŠ æ»šè½®æ•æ„Ÿåº¦
            new_sensitivity = min(1.0, self.scroll_sensitivity + 0.1)
            self.set_scroll_sensitivity(new_sensitivity)
        elif a0.key() == Qt.Key_Minus:  # - é”®å‡å°‘æ»šè½®æ•æ„Ÿåº¦
            new_sensitivity = max(0.1, self.scroll_sensitivity - 0.1)
            self.set_scroll_sensitivity(new_sensitivity)
        elif a0.key() == Qt.Key_0:  # 0 é”®é‡ç½®æ»šè½®è®¾ç½®
            self.set_scroll_sensitivity(0.3)
            self.set_scroll_threshold(10)
            self.set_scroll_max_distance(100)
            print("ğŸ”„ æ»šè½®è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼")
        if a0.key() == Qt.Key_Backslash:  # è¿”æ–œæ 
            print('ç”ŸæˆæŠ€èƒ½å›¾å½¢æŒ‡çº¹å®Œæˆ')
        return super().keyPressEvent(a0)

    def keyReleaseEvent(self, a0: QtGui.QKeyEvent) -> None:
        if a0.isAutoRepeat():
            return
        if a0.key() == Qt.Key.Key_Alt:
            self.key_alt_down = False
        if a0.key() == Qt.Key.Key_Control:
            self.key_ctrl_down = False
        # if a0.key() == Qt.Key_Space:
        #     self.character.use_skill_manually_up(self.character.skill_normal_attack)
        # elif a0.key() == Qt.Key_A:
        #     self.character.use_skill_manually_up(self.character.skill_riding_slot)
        # elif a0.key() == Qt.Key_Q:
        #     self.character.use_skill_manually_up(self.character.skill_main_weapon_slot1)
        # elif a0.key() == Qt.Key_W:
        #     self.character.use_skill_manually_up(self.character.skill_main_weapon_slot2)
        # elif a0.key() == Qt.Key_E:
        #     self.character.use_skill_manually_up(self.character.skill_main_weapon_slot3)
        # elif a0.key() == Qt.Key_R:
        #     self.character.use_skill_manually_up(self.character.skill_armor_slot)
        # elif a0.key() == Qt.Key_F:
        #     self.character_master.use_skill_manually_up(self.character.skill_shoes_slot)
        # elif a0.key() == Qt.Key_D:
        #     self.character.use_skill_manually_up(self.character.skill_head_slot)
        # elif a0.key() == Qt.Key_C:
        #     self.character.bag()
        return super().keyReleaseEvent(a0)





    def closeEvent(self, a0: QtGui.QCloseEvent) -> None:
        
        return super().closeEvent(a0)


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)

    # è·å–å¯ç”¨çš„è®¾å¤‡åˆ—è¡¨
    try:
        import subprocess
        result = subprocess.run(['adb', 'devices'], capture_output=True, text=True, timeout=5)
        lines = result.stdout.strip().split('\n')[1:]  # è·³è¿‡ç¬¬ä¸€è¡Œæ ‡é¢˜
        devices = []
        for line in lines:
            if line.strip() and 'device' in line:
                device_id = line.split()[0]
                devices.append(device_id)
        
        if not devices:
            print("âŒ æ²¡æœ‰æ‰¾åˆ°è¿æ¥çš„Androidè®¾å¤‡")
            print("è¯·ç¡®ä¿ï¼š")
            print("1. è®¾å¤‡å·²è¿æ¥å¹¶å¼€å¯USBè°ƒè¯•")
            print("2. ADBé©±åŠ¨å·²æ­£ç¡®å®‰è£…") 
            print("3. åœ¨è®¾å¤‡ä¸Šå…è®¸USBè°ƒè¯•æˆæƒ")
            sys.exit(1)
        
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨è®¾å¤‡
        device_id = devices[0]
        print(f"âœ… å‘ç°è®¾å¤‡: {device_id}")
        
    except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"âŒ ADBå‘½ä»¤æ‰§è¡Œå¤±è´¥: {e}")
        print("è¯·ç¡®ä¿ADBå·²å®‰è£…å¹¶åœ¨PATHç¯å¢ƒå˜é‡ä¸­")
        print("âš ï¸  å¯åŠ¨æ¨¡æ‹Ÿè®¾å¤‡æ¨¡å¼...")

    win = MyWin(device_id)
    win.show()

    n = app.exec_()
    sys.exit(n)